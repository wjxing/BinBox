#!/bin/bash
MY_CLEAN=false
MY_FAIL=false
MY_TAG_NAME=false
MY_LANG=all
MY_PRUNE_PATH=
MY_PRUNE_OPT=
MY_DEF_PRUNE_PATH=.git
MY_FIND_CMD=
MY_FIND_FILTER=
MY_TAGS_DIR=".vim/tags"
MY_TAGS_PATH="~/$MY_TAGS_DIR"
MY_TAGS_ABS_PATH=$HOME/$MY_TAGS_DIR

check_args()
{
    if [ $# -lt 1 ]; then
        MY_FAIL=true
        return
    fi
    while [ -n "$1" ]
    do
        case "$1" in
            temp) MY_TAG_NAME="temp";;
            cpp) MY_LANG="cpp";;
            java) MY_LANG="java";;
            clean) MY_CLEAN="true";;
            tname=[a-z]*) MY_TAG_NAME="$1";;
            prune=.*) MY_PRUNE_PATH="$1";;
        esac
        shift
    done

}

check_args $*

if [ "$MY_PRUNE_PATH###" != "###" ]; then
    MY_PRUNE_PATH=`echo $MY_PRUNE_PATH | awk -F "=" '{print $2}'`
    MY_PRUNE_PATH=$MY_PRUNE_PATH,
fi

MY_PRUNE_PATH=$MY_PRUNE_PATH$MY_DEF_PRUNE_PATH

MY_PRUNE_OPT=`echo $MY_PRUNE_PATH | sed -e 's/,/ -o -path /g'`
MY_PRUNE_OPT="\( \( -path $MY_PRUNE_OPT \) -prune \) -o"

MY_TAG_NAME=`echo $MY_TAG_NAME | awk -F "=" '{print $2}'`
if [[ "$MY_TAG_NAME###" != "###" && $MY_TAG_NAME != "false" ]]; then
    LOAD_TAG_VIM="set tags+=$MY_TAGS_PATH/$MY_TAG_NAME/ctags.tag"
    echo $LOAD_TAG_VIM > loadtag.vim
fi

if [[ $MY_CLEAN == "true" ]]; then
    rm -f loadtag.vim lookuptags
    if [ -d $MY_TAGS_ABS_PATH/$MY_TAG_NAME ]; then
        rm -rf $MY_TAGS_ABS_PATH/$MY_TAG_NAME
    fi
    exit 0
fi

if [[ $MY_FAIL != "true" && $MY_TAG_NAME != "false" ]]; then
    if [ $MY_LANG = "all" ]; then
        MY_FIND_FILTER='-name "*.h" -o -name "*.c" -o -name "*.cpp" -o -name "*.java" -o -name "*.s" -o -name "*.S"'
    elif [ $MY_LANG = "cpp" ]; then
        MY_FIND_FILTER='-name "*.h" -o -name "*.c" -o -name "*.cpp" -o -name "*.s" -o -name "*.S"'
    else
        MY_FIND_FILTER='-name "*.java"'
    fi
    MY_FIND_CMD='find ./ '$MY_PRUNE_OPT' \( ! -type l -type f -a \( '$MY_FIND_FILTER' \) -a -print \)'
    tramp=$MY_TAGS_ABS_PATH/$MY_TAG_NAME
    mkdir -p "$tramp"
    eval $MY_FIND_CMD > $tramp/gtags.files
    gtags -f $tramp/gtags.files $tramp
    ctags -R -f $tramp/ctags.tag --tag-relative=yes -L $tramp/gtags.files
    # generate tag file for lookupfile plugin
    echo -e "!_TAG_FILE_SORTED\t2\t/2=foldcase/" > lookuptags
    #find -L . -not -regex '.*\.\(png\|gif\)' -type f -printf "%f\t%p\t1\n" | \
    #    sort -f >> lookuptags
    MY_FIND_CMD='find ./ '$MY_PRUNE_OPT' \( ! -type l -type f -a \( '$MY_FIND_FILTER' \) -a -printf "%f\t%p\t1\n" \)'
    eval $MY_FIND_CMD | sort -f >> lookuptags

    cat << EOF >> loadtag.vim
function! UpdateGtags(f)
  let dir = fnamemodify(a:f, ':p:h')
  exe 'silent !gtags -f $tramp/gtags.files --single-update ' . a:f . ' $tramp &'
endfunction

let \$GTAGSROOT="$PWD"
let \$GTAGSDBPATH="$tramp"

set csprg=$HOME/bin/global/bin/gtags-cscope
set nocsverb
cs add $tramp/GTAGS
set csverb
au BufWritePost *.java call UpdateGtags(expand('<afile>'))
au BufWritePost *.[ch] call UpdateGtags(expand('<afile>'))
au BufWritePost *.cpp call UpdateGtags(expand('<afile>'))

" search cscope file first, NOT tag file
set csto=0
" search cscope and tag file
set cst
" set cscopequickfix=s-,c-,d-,i-,t-,e-,g-
" s: 查找C语言符号，即查找函数名、宏、枚举值等出现的地方
" g: 查找函数、宏、枚举等定义的位置，类似ctags所提供的功能
" c: 查找调用本函数的函数
" t: 查找指定的字符串
" e: 查找egrep模式，相当于egrep功能，但查找速度快多了
" f: 查找并打开文件，类似vim的find功能
" i: 查找包含本文件的文件
" d: 查找本函数调用的函数
nmap <C-\>s :cscope find s <C-R>=expand("<cword>")<CR><CR>
nmap <C-\>g :cscope find g <C-R>=expand("<cword>")<CR><CR>
nmap <C-\>c :cscope find c <C-R>=expand("<cword>")<CR><CR>
nmap <C-\>t :cscope find t <C-R>=expand("<cword>")<CR><CR>
nmap <C-\>e :cscope find e <C-R>=expand("<cword>")<CR><CR>
nmap <C-\>f :cscope find f <C-R>=expand("<cfile>")<CR><CR>
nmap <C-\>i :cscope find i ^<C-R>=expand("<cfile>")<CR>$<CR>
nmap <C-\>d :cscope find d <C-R>=expand("<cword>")<CR><CR>
EOF

fi

if [ "$MY_FAIL" = "true" ]; then
    echo "arg error"
fi

if [ "$MY_TAG_NAME" = "false" ]; then
    echo "tag error"
fi
